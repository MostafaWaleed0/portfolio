---
title: Building a blog with Next.js
description: In this tutorial, we'll use Next.js to create a static-generated, production-ready blog. We'll go through the process of static site generation (SSG) and create a fantastic blog with strong SEO.
banner: /images/building-a-blog-with-nextjs/og.jpg
date: 2022-09-01
tags:
  - react
  - nextjs
  - typescript
---

Iâ€™ve been building with React for years now, and somewhere along that journey, I stumbled into the wonderful chaos of static blogs, SEO, and content workflows. I used to think that making a high-performance blog meant juggling endless build tools, patching together plugins, and writing more config than content. Then I met **Next.js**.

It wasnâ€™t love at first sight â€” I came from the land of create-react-app, and server-side rendering sounded like black magic. But the more I used it, the more I realized how much complexity it quietly handled for me.

Fast-forward to today: if you asked me how to build a **fast, SEO-friendly blog** without drowning in boilerplate, Iâ€™d tell you â€” without hesitation â€” use Next.js.

## Why Next.js for blogs just works

SEO has always been a bit of a frenemy to developers. We know itâ€™s important, but weâ€™d rather be building features than fiddling with meta tags. Next.js makes SEO-friendly static generation (SSG) painless. You write content in MDX, sprinkle in your React components, and ship a site thatâ€™s production-ready before your coffee gets cold.

Thatâ€™s the experience I wanted to share in this post: how I built a static-generated, production-ready blog with **Next.js, MDX, and a handful of plugins**.

## Spinning up the project

It started with one command:

```bash
npx create-next-app@latest site --typescript
```

From there, I laid out the folder structure the way I like to think about content and code:

```
site
 â”œâ”€ lib
 â”‚   â”œâ”€ mdx.ts
 â”‚   â””â”€ types.ts
 â”œâ”€ pages
 â”‚   â”œâ”€ blog
 â”‚   â”‚   â””â”€ [slug].tsx
 â”‚   â”œâ”€ _app.tsx
 â”‚   â”œâ”€ _document.tsx
 â”‚   â””â”€ blog.tsx
 â””â”€ posts
     â””â”€ ğŸ‰.mdx
```

If youâ€™ve been around static site generators before, youâ€™ll recognize the pattern:

- `lib/` for logic that transforms content
- `pages/` for routes
- `posts/` forâ€¦ well, the actual posts.

## The magic sauce: MDX

For me, MDX is like Markdown but on steroids â€” it lets me drop React components right into my writing. To make it work with syntax highlighting, heading anchors, and other niceties, I wired up a small helper in `lib/mdx.ts`:

```ts
import { serialize } from 'next-mdx-remote/serialize';
import remarkGfm from 'remark-gfm';
import rehypeSlug from 'rehype-slug';
import rehypeCodeTitles from 'rehype-code-titles';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import rehypePrism from 'rehype-prism-plus';

export async function mdxToHtml(source: string) {
  const mdxSource = await serialize(source, {
    mdxOptions: {
      remarkPlugins: [remarkGfm],
      rehypePlugins: [
        rehypeSlug,
        rehypeCodeTitles,
        rehypePrism,
        [
          rehypeAutolinkHeadings,
          {
            properties: { className: ['anchor'] }
          }
        ]
      ],
      format: 'mdx'
    }
  });

  return { html: mdxSource };
}
```

I still remember the first time I saw my headings turn into clickable links automatically. Thatâ€™s `rehypeSlug` + `rehypeAutolinkHeadings` working their quiet magic.

## Defining types early (thank me later)

In `lib/types.ts`, I wrote my TypeScript interfaces so my editor could stop nagging me later:

```ts
import { MDXRemoteSerializeResult } from 'next-mdx-remote';

export interface PostPageType {
  slug: string;
  frontmatter: {
    title: string;
    description: string;
    date: string;
  };
  content: MDXRemoteSerializeResult;
}

export interface BlogPostType {
  [key: string]: Array<PostPageType>;
}
```

## The first post

I wrote my very first `.mdx` file like this:

```mdx
---
title: party
description: We'll celebrate now.
date: 2022-08-31
---

# ğŸ‰ Party Time

Because why not.
```

Nothing fancy â€” but it was enough to wire up the reading and rendering logic.

## Listing posts

In `pages/blog.tsx`, I used `gray-matter` to pull the front matter from each post and list them:

```ts
export async function getStaticProps() {
  const files = readdirSync(join(process.cwd(), 'posts'));
  const posts = files.map((filename) => {
    const slug = filename.replace('.mdx', '');
    const markdownWithMeta = readFileSync(
      join(process.cwd(), 'posts', filename),
      'utf-8'
    );
    const { data: frontmatter } = matter(markdownWithMeta);
    return { slug, frontmatter };
  });

  return { props: { posts } };
}
```

When I first saw my blog list render, I felt like I had just unlocked the â€œblogger achievementâ€ in developer life.

## Rendering a single post

Finally, `pages/blog/[slug].tsx` tied it all together. `getStaticPaths` maps out every post route, `getStaticProps` loads the MDX, and `MDXRemote` renders it.

That was the moment it hit me:
I now had a **fully static, blazing-fast, SEO-friendly blog** â€” and I didnâ€™t fight with webpack once.

## Final thoughts

If thereâ€™s one takeaway from this build, itâ€™s that **Next.js removes the mental tax** from shipping a blog. You focus on the content, sprinkle in a few plugins for nice-to-haves, and youâ€™re done.

And the best part? You can always grow it â€” add tags, RSS feeds, or even drop in live components. But the foundation stays the same: simple, fast, and production-ready.
